##第一周
#### 第1讲
1. 操作系统接到了用户的请求之后 就会根据用户提供的文件名 到磁盘上找到这个程序的相关信息 找到信息之后，会去检查这个程序 是不是一个可执行文件，因为有的时候我们 的一个文件它不是可执行文件，那么操作系统就不能执行这个文件 就会去报错，那么如果是一个可执行文件，操作系统才能正确地执行 在检查完类型之后，操作系统会根据程序首部信息 来确定代码和数据在这个可执行文件当中的位置 并计算出它相应的磁盘块地址


2. 操作系统首先要创建一个新的进程 并将helloworld程序的可执行文件格式 映射到该进程结构 表示由该进程来执行这个helloworld程序 做完了这件事情，操作系统就把控制权 交给了调度程序，我们假设调度程序 正好选中了helloworld程序，那么 由操作系统为这个helloworld程序设置CPU 上下文环境，并跳到程序的开始之处 准备执行这条这个程序，那么下一个指令周期就是执行helloworld程序了

#### 第2讲
1. 方便使用: 用户界面和编程接口
2. 管理资源要用到数据结构和算法:  
确定资源分配策略:
(1) 静态分配资源: 会导致资源的浪费
(2) 动态分配资源
3. 资源管理角度的五大基本功能:
(1) 进程线程管理 (CPU管理)
(2) 存储管理
(3) 文件管理
(4) 设备管理
(5) 用户接口
4. 硬件操作复杂繁琐. 操作系统对硬件抽象, 提高可编程性

#### 第3讲
1. 操作系统的特征:
(1) 并发: 处理多个同时性的活动.
(2) 共享: 操作系统与多个用户的程序共同使用计算机系统的资源. 互斥共享 和 同时共享
(3) 虚拟: 一个物理实体映射为多个对应的逻辑实体 -- 分时或者分空间
(4) 随机: 必须随时对以不可预测的次序发生的事件进行响应并处理. 
进程的运行速度不可预知. 难以重现系统在某个时刻的状态.

#### 第4讲
windows架构几乎所有的硬件相关操作都被封装在: HAL(硬件抽象层), kernal(内核层)两层

#### 第5讲
操作系统分类:   
- 批处理操作系统: Spooling系统(simultaneous peripheral operation on-line 同时的外部设备联机操作计数, 1961),是用磁盘做缓冲 将输入、 计算、 输出分别组织成独立的任务流 在一台计算机上执行，使得输入、 输出和计算真正并行.   
输入进程 作业调度 作业处理 输出进程
- 分布式操作系统: 或以计算机网络为基础, 或以多处理机为基础, 基本特征是处理分布在不同的计算机上

## 第二周
#### 第6讲
1. CPU中的寄存器可以分为`用户可见寄存器`和`控制和状态寄存器`. 后者用于控制处理器的操作, 由操作系统代码使用.在某种特权级别下可以访问 修改.  
常见的控制和状态寄存器:   
* PC(program count)程序计数器, 记录将要取出的指令的地址  
* IR(instruction register)指令寄存器, 记录最近取出的指令  
* PSW(program state word) 程序状态字, 记录处理器的运行状态如条件码 模式 控制位等信息.   

2. 操作系统的需求: 保护  
实现保护与控制. 需要硬件提供基本运行机制: 
- 处理器具有特权级别, 能在不同特权级运行不同的指令
- 硬件机制可分离OS和用户程序

操作系统两种CPU状态: 内核态 用户态  
指令分为特权指令(privilege command)和非特权指令

e.g. X86架构支持4个处理器特权级别: R0(内核态), R1,R2, R3(用户态)

用户态->内核态唯一途径: 中断/异常/陷入机制  
内核态->用户态: 设置PSW  
特殊指令: 陷入指令(访管指令,因为内核态也称为supervisor mode). 提供给用户程序的接口, 用于调用操作系统的功能(int, trap, syscall, sysenter/sysexit)

异常又分为:  
- 陷入(trap): 有意识安排的. 返回的时候返回到下一条指令.
- 故障(fault): 可恢复的错误. 返回的时候返回到当前指令.
- 终止(abort): 不可恢复的错误. 不会返回.

在每条指令执行周期的最后时刻 扫描中断寄存器 查看是否有中断信号. 
中断向量: 一个内存单元, 存放中断处理程序`入口地址`和程序运行时所需的`处理机状态字`. 


3. X86架构对异常/中断的处理:  
(1) 确定与中断或异常关联的向量i
(2) 通过IDTR寄存器找到IDT表, 获得中断描述符. 进而获得偏移地址.
(3) 从GDTR寄存器获得GDT地址, 结合中断描述符中的段选择符, 在GDT表获取对应的段描述符. 从该段描述符中得到中断或异常处理程序所在的段基址. 
(4) 特权级检查
    - 检查是否发生了特权级的变化. 如果是, 则进行堆栈切换. 必须使用与新的特权级相关的栈. 



4. 系统调用system call
全称操作系统编程调用. 
系统调用,库函数, API, 内核函数的关系:  
通常情况下, 应用程序通过调用C库函数或者API接口, 间接进行系统调用.应用程序也可以直接调用系统 但是比较少见. 内核函数就是系统调用的处理程序. 

5. 用户程序参数传递给内核:  
- 由陷入指令自带参数
- 通过通用寄存器传递参数: 通用寄存器用户程序和内核程序都可以访问
- 在内存中开辟专用堆栈区

`int 0x80  ; 汇编 引发一次系统调用`

6. Intel对中断描述符的分类   
- 任务门(task gate) 
    当中断信号发生时，必须取代当前进程的那个进程的TSS选择符存放在任务门中。
- 中断门(interruptgate) 
    包含段选择符和中断或异常处理程序的段内偏移量.当控制权转移到一个适当的段时，处理器 清IF标志，从而关闭将来会发生的可屏蔽中断.
陷阱门(Trap gate)
    与中断门相似，只是控制权传递到一个适当的段时处理器不修改IF标志. 
 对于中断门，在转移过程中把IF置为0，使得在处理程序执行期间屏蔽掉INTR中断(当然，在中断处理程序中可以人为设置IF标志打开中断，以使得在处理程序执行期间允许响应可屏蔽中断)；对于陷阱门，在转移过程中保持IF位不变，即如果IF位原来是1，那么通过陷阱门转移到处理程序之后仍允许INTR中断。因此，中断门最适宜于处理中断，而陷阱门适宜于处理异常。


## 第三周
1. 多道程序设计(Multiprogramming)
允许多个程序同时进入内存并运行.

2. 并发环境: 一段时间间隔内, 单个CPU上有两个或两个以上程序同时处于开始运行但尚未结束的状态. 并且次序不是事先确定的.

3. 进程(process): 用于刻画并发环境下程序的执行. 进程是具有独立功能的程序关于某个数据集合上的一次运行活动. 是系统进行__资源分配__和__调度__的独立单位. 又称任务.

4. 进程控制块(process control block): 进程描述符, 进程属性. 操作系统用于管理控制进程的一个专门的数据结构. 记录进程的各种属性, 描述进程的动态变化过程. PCB是操作系统感知进程存在的唯一标志. 所有进程的PCB集合称为进程表.  
- 进程描述信息: 进程标识符, 进程名, 用户标识符, 进程组. 
- 进程控制信息: 当前状态, 优先级, 代码执行入口程序, 程序磁盘地址, 运行统计信息, 进程间同步和通信. 
- 所拥有的资源和使用情况: 虚拟地址空间的状况, 打开文件列表.
- CPU现场信息: 寄存器值(通用寄存器, 程序计数器PC, PSW), 指向该进程列表的指针. 


