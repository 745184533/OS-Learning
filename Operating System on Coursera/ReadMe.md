##第一周
#### 第1讲
1. 操作系统接到了用户的请求之后 就会根据用户提供的文件名 到磁盘上找到这个程序的相关信息 找到信息之后，会去检查这个程序 是不是一个可执行文件，因为有的时候我们 的一个文件它不是可执行文件，那么操作系统就不能执行这个文件 就会去报错，那么如果是一个可执行文件，操作系统才能正确地执行 在检查完类型之后，操作系统会根据程序首部信息 来确定代码和数据在这个可执行文件当中的位置 并计算出它相应的磁盘块地址


2. 操作系统首先要创建一个新的进程 并将helloworld程序的可执行文件格式 映射到该进程结构 表示由该进程来执行这个helloworld程序 做完了这件事情，操作系统就把控制权 交给了调度程序，我们假设调度程序 正好选中了helloworld程序，那么 由操作系统为这个helloworld程序设置CPU 上下文环境，并跳到程序的开始之处 准备执行这条这个程序，那么下一个指令周期就是执行helloworld程序了

#### 第2讲
1. 方便使用: 用户界面和编程接口
2. 管理资源要用到数据结构和算法:  
确定资源分配策略:
(1) 静态分配资源: 会导致资源的浪费
(2) 动态分配资源
3. 资源管理角度的五大基本功能:
(1) 进程线程管理 (CPU管理)
(2) 存储管理
(3) 文件管理
(4) 设备管理
(5) 用户接口
4. 硬件操作复杂繁琐. 操作系统对硬件抽象, 提高可编程性

#### 第3讲
1. 操作系统的特征:
(1) 并发: 处理多个同时性的活动.
(2) 共享: 操作系统与多个用户的程序共同使用计算机系统的资源. 互斥共享 和 同时共享
(3) 虚拟: 一个物理实体映射为多个对应的逻辑实体 -- 分时或者分空间
(4) 随机: 必须随时对以不可预测的次序发生的事件进行响应并处理. 
进程的运行速度不可预知. 难以重现系统在某个时刻的状态.

#### 第4讲
windows架构几乎所有的硬件相关操作都被封装在: HAL(硬件抽象层), kernal(内核层)两层

#### 第5讲
操作系统分类:   
- 批处理操作系统: Spooling系统(simultaneous peripheral operation on-line 同时的外部设备联机操作计数, 1961),是用磁盘做缓冲 将输入、 计算、 输出分别组织成独立的任务流 在一台计算机上执行，使得输入、 输出和计算真正并行.   
输入进程 作业调度 作业处理 输出进程
- 分布式操作系统: 或以计算机网络为基础, 或以多处理机为基础, 基本特征是处理分布在不同的计算机上

## 第二周
#### 第6讲
1. CPU中的寄存器可以分为`用户可见寄存器`和`控制和状态寄存器`. 后者用于控制处理器的操作, 由操作系统代码使用.在某种特权级别下可以访问 修改.  
常见的控制和状态寄存器:   
* PC(program count)程序计数器, 记录将要取出的指令的地址  
* IR(instruction register)指令寄存器, 记录最近取出的指令  
* PSW(program state word) 程序状态字, 记录处理器的运行状态如条件码 模式 控制位等信息.   

2. 操作系统的需求: 保护  
实现保护与控制. 需要硬件提供基本运行机制: 
- 处理器具有特权级别, 能在不同特权级运行不同的指令
- 硬件机制可分离OS和用户程序

操作系统两种CPU状态: 内核态 用户态  
指令分为特权指令(privilege command)和非特权指令

e.g. X86架构支持4个处理器特权级别: R0(内核态), R1,R2, R3(用户态)

用户态->内核态唯一途径: 中断/异常/陷入机制  
内核态->用户态: 设置PSW  
特殊指令: 陷入指令(访管指令,因为内核态也称为supervisor mode). 提供给用户程序的接口, 用于调用操作系统的功能(int, trap, syscall, sysenter/sysexit)

异常又分为:  
- 陷入(trap): 有意识安排的. 返回的时候返回到下一条指令.
- 故障(fault): 可恢复的错误. 返回的时候返回到当前指令.
- 终止(abort): 不可恢复的错误. 不会返回.

在每条指令执行周期的最后时刻 扫描中断寄存器 查看是否有中断信号. 
中断向量: 一个内存单元, 存放中断处理程序`入口地址`和程序运行时所需的`处理机状态字`. 


3. X86架构对异常/中断的处理:  
(1) 确定与中断或异常关联的向量i
(2) 通过IDTR寄存器找到IDT表, 获得中断描述符. 进而获得偏移地址.
(3) 从GDTR寄存器获得GDT地址, 结合中断描述符中的段选择符, 在GDT表获取对应的段描述符. 从该段描述符中得到中断或异常处理程序所在的段基址. 
(4) 特权级检查
    - 检查是否发生了特权级的变化. 如果是, 则进行堆栈切换. 必须使用与新的特权级相关的栈. 



4. 系统调用system call
全称操作系统编程调用. 
系统调用,库函数, API, 内核函数的关系:  
通常情况下, 应用程序通过调用C库函数或者API接口, 间接进行系统调用.应用程序也可以直接调用系统 但是比较少见. 内核函数就是系统调用的处理程序. 

5. 用户程序参数传递给内核:  
- 由陷入指令自带参数
- 通过通用寄存器传递参数: 通用寄存器用户程序和内核程序都可以访问
- 在内存中开辟专用堆栈区

`int 0x80  ; 汇编 引发一次系统调用`

6. Intel对中断描述符的分类   
- 任务门(task gate) 
    当中断信号发生时，必须取代当前进程的那个进程的TSS选择符存放在任务门中。
- 中断门(interruptgate) 
    包含段选择符和中断或异常处理程序的段内偏移量.当控制权转移到一个适当的段时，处理器 清IF标志，从而关闭将来会发生的可屏蔽中断.
陷阱门(Trap gate)
    与中断门相似，只是控制权传递到一个适当的段时处理器不修改IF标志. 
 对于中断门，在转移过程中把IF置为0，使得在处理程序执行期间屏蔽掉INTR中断(当然，在中断处理程序中可以人为设置IF标志打开中断，以使得在处理程序执行期间允许响应可屏蔽中断)；对于陷阱门，在转移过程中保持IF位不变，即如果IF位原来是1，那么通过陷阱门转移到处理程序之后仍允许INTR中断。因此，中断门最适宜于处理中断，而陷阱门适宜于处理异常。


## 第三周
1. 多道程序设计(Multiprogramming)
允许多个程序同时进入内存并运行.

2. 并发环境: 一段时间间隔内, 单个CPU上有两个或两个以上程序同时处于开始运行但尚未结束的状态. 并且次序不是事先确定的.

3. 进程(process): 用于刻画并发环境下程序的执行. 进程是具有独立功能的程序关于某个数据集合上的一次运行活动. 是系统进行__资源分配__和__调度__的独立单位. 又称任务.

4. 进程控制块(process control block): 进程描述符, 进程属性. 操作系统用于管理控制进程的一个专门的数据结构. 记录进程的各种属性, 描述进程的动态变化过程. PCB是操作系统感知进程存在的唯一标志. 所有进程的PCB集合称为进程表.  
- 进程描述信息: 进程标识符, 进程名, 用户标识符, 进程组. 
- 进程控制信息: 当前状态, 优先级, 代码执行入口程序, 程序磁盘地址, 运行统计信息, 进程间同步和通信. 
- 所拥有的资源和使用情况: 虚拟地址空间的状况, 打开文件列表.
- CPU现场信息: 寄存器值(通用寄存器, 程序计数器PC, PSW), 指向该进程列表的指针. 

5. 进程的三个基本状态: 
- 运行态(running): 占有CPU,并在CPU上运行.
- 就绪态(ready): 已经具备运行条件, 但由于没有空闲CPU, 而暂时不能运行.
- 等待态(waiting/blocked): 阻塞态 封锁态 睡眠态.因等待某一事件而暂时不能运行. e.g.等待读盘结果

运行态只能由就绪态进入.等待态等待的信号到达后进入就绪态.  
还有其他状态比如创建态和终止态, 还有挂起态. 

6. 进程控制操作完成进程各状态之间的转换, 由具有特定功能的原语完成(primitive). 完成某种特定功能的一段程序, 具有不可分割性和不可中断性. 即原语的执行必须是连续的, 在执行工程中不允许被中断. 

7. 进程创建:
* 给新进程分配一个唯一标识及进程控制块(PCB)
* 为进程分配地址空间
* 初始化进程控制块(设置默认值)
* 设置相应的队列指针(把新进程添加到就绪队列链表中)
* Unix: fork/exec; windows:CreateProcess

8. 收回进程:
* 收回进程所占用的资源
* 撤销该进程的PCB
* Unix: exit; windows: TerminateProcess

9. 进程阻塞: 
- 当被等待的事件尚未发生时, 由进程自己执行阻塞原语, 使自己由运行态变为阻塞态.
- Unix: wait; windows: WaitForSingleObject

10. Unix Fork()函数的实现
- 为子进程分配一个空闲的进程描述符(proc结构)
- 分配给子进程唯一标识符: PID
- 以一次一页的方式 复制父进程地址空间 (Linux采用了写时复制计数copy on write)
- 从父进程那里继承共享资源, 如打开的文件和当前工作目录等
- 将子进程的状态设置为就绪, 插入到就绪队列
- 对子进程返回标识符0
- 对父进程返回标识符PID
- fork执行完后, 进程一分为二

11. 进程分为 系统进程, 用户进程; 前台进程, 后台进程; CPU密集型进程(玩游戏, 画面渲染, 大量计算), I/O密集型进程. Unix进程家族树: init为根. Windows进程地位相同.

12. Context switch 进程切换
将CPU硬件状态从一个进程切换到另一个进程. CPU运行时, 其硬件状态保存在CPU上的寄存器中. 进程不运行时, 这些寄存器的值保存在进程控制块PCB中. 

13. 线程(thread):   
进程可以让程序并发执行, 为什么要再派生出线程:(1)应用的需要 (2)开销的考虑 (3)性能的考虑
有三个线程的字处理软件: (1)输入(2)排版(3)定时保存,存储  
多线程web服务器:(有并发, 阻塞系统调用)  
- 分派线程(dispatcher thread): 监听客户端,分发
- 工作线程(worker thread): 查找

也可以使用单线程进程: 无并发, 阻塞系统调用(速度慢)  或者有限状态机: 有并发, 非阻塞系统调用, 中断 (编程模型复杂)  
进程开销大, 限制了并发度的提高. 线程开销小, 创建撤销速度快, 线程切换时间短, 不需要系统介入, 相互通信无须调用内核.

因此线程是进程中的一个运行实体, 是CPU的调度单位. 线程有标识符ID, 状态及状态转换, 需要保存上下文, 有自己的栈和栈指针, 共享所在进程的地址空间和其他资源, 可以创建和撤销另一个线程.


14. 线程的实现
(1) 用户级线程(user level thread): 内核管理还是进程, 不知道线程的存在. 线程切换不需要内核干预. Unix. 多个线程不能运行在多个CPU上  
(2) 核心级线程(kernel level thread): 内核管理所有线程, 既有进程表, 又有线程表. 内核维护线程进程的上下文. 线程切换需要内核支持. Windows
(3) 混合模型: 线程创建在用户空间完成, 线程调度在内核空间完成. Solaris.

15. 可再入程序(可重入)
可被多个进程同时调用的程序, 它是纯代码的, 即在执行过程中自身不改变, 调用它的进程应该提供数据区. 

16. 测验:
(1) 假设某单处理器计算机系统中有10个进程，则系统中处于等待状态的进程最多有几个？
运行状态最多 1 最少0  
等待状态最多 n 最少0  
就绪状态最多 n-1 最少0  
(2) 进程控制原语: 进程控制原语包括：进程的建立、进程的撤销、进程的等待和进程的唤醒,改变进程优先级。
(3) 当某个正在执行的进程需要进行I/O操作时，可以通过调用挂起(错误, 阻塞)原语将自己从运行状态变为等待状态。
(4) 线程共享的环境包括：进程代码段、进程的公有数据(利用这些共享的数据，线程很容易的实现相互之间的通讯)、进程打开的文件描述符、信号的处理器、进程的当前目录和进程用户ID与进程组ID。   
栈是每个线程独有的，保存其运行状态和局部自动变量的。栈在线程开始的时候初始化，每个线程的栈互相独立，因此，栈是 thread safe 的。
(5) 撤销进程的具体操作过程是：找到要被撤销进程的PCB，将它从所在队列中消去，撤销属于该进程的一切“子孙进程”，释放被撤销进程所占用的全部资源，并消去被撤销进程的PCB。


## 第四周
1. CPU调度: 其任务是控制,协调进程对CPU的竞争. 如果没有就绪进程, 系统会安排空闲进程或者idle进程
2. 上下文切换开销(cost): 直接开销(内核完成切换所需要的时间, 包括保存,恢复寄存器, 切换地址空间). 间接开销(原来进程所使用的高速缓存 cache, 缓冲区缓存 buffer cache, TLB(Translation Lookup Buffer)等的失效)
3. 调度算法衡量指标: 
- 吞吐量(Troughput): 单位时间完成进程的数目
- 周转时间(Turnaround Time, TT): 每个进程从提出请求到运行完成的时间
- 响应时间(Response Time, RT): 从提出请求到第一次响应的时间
4. 占用CPU的方式: 抢占式和非抢占式.
* 可抢占式(Preemptive): 更高优先级的进程就绪时, 系统强行剥夺正在运行的进程的CPU使用. 
* 不可抢占(Non-preemptive): 除非由他自身完成或者主动放弃CPU使用, 不然不能被剥夺对CPU的使用

5. 时间片(Time Slice or quantum 量子的)
6. 主要区别在作业执行过程中，由用户使用操作系统提供操作控制命令。就是给一个命令就执行一个，而批处理就要预编。
7. 批处理系统中采用的调度算法(主要指标: 吞吐量, 响应时间, 平均执行时间)
- 先来先服务(First Come First Service)
非抢占, 按照进程就绪的先后顺序使用CPU
- 最短作业优先(Shortest Job First)
具有最短完成时间的进程优先完成. 可以得到最短的平均周转时间, 不过可能有不公平的现象. 
- 最短剩余时间优先(Shortest Remaining Time Next)
最短作业优先的抢占式算法, 当一个新就绪的进程的运行时间比当前正在运行的进程的剩余时间还要短的情况下, 系统抢占当前进程, 选择新就绪的进程执行
- 最高响应比优先(Highest Response Ration Next)
综合算法, 计算响应比 = 周转时间/处理时间 = (处理时间+等待时间) / 处理时间 


8. 交互式系统中采用的调度算法(指标: 响应时间 公平):
- 轮转调度(Round Robin)
周期性切换, 每个进程分配一个时间片, 通过时钟中断进行轮换. 公平, 由于进程切换, 不合适的时间片造成系统开销过大.
- 最高优先级调度(Highest Priority First)
选择优先级最高的进程进行执行. 抢占式的优先级调度算法会带来优先级翻转的问题, 解决方法包括优先级继承和使用中断禁止等方法.
- 多级反馈队列(Multilevel Feedback Queue)
    * 设置多个就绪队列, 其中第一个的优先级最高;
    * 不同就绪队列的进程分配长度不同的时间片, 第一级队列时间片最少, 随着优先级降低, 时间片增大
    * 调度的时候从高优先级的队列进行调度
    * 当一个新创建的进程就绪后, 进入第一级队列
    * 如果对应的时间片用完还没有执行完, 就放入第二级队列 以此类推.
    * 由于阻塞而放弃CPU的进程放入等待队列, 一旦等待的事件到达, 该进程回到原来的那级就绪队列
    * 抢占或者非抢占式都可以被设计
- 最短进程优先(Shortest Process Next)
类似最短作业优先

9. windows的线程调度算法
调度单位是线程, 采用基于动态优先级的, 抢占式调度, 结合时间配额的调整. 就绪线程按照优先级进入队列,系统选择优先级最高的就绪线程运行, 同一优先级的各线程按时间片轮转进行调度. 多CPU系统中允许多个线程并行执行.  
Windows使用32个优先级: 0系统线程, 1-15可变优先级, 16-31实时优先级(一旦确定就不能改变)

### 第五周
1. 并发: 进程的执行是间断性的, 相对执行时间不可预测. 执行的结果和它的执行速度有关, 是不确定的. 
2. 竞争条件: 两个或多个进程读写某些共享数据, 而最后的结果取决于进程运行的精确时序. 临界区: 各个进程中对某个临界资源(互斥资源)实施操作的程序片段.  
所谓优先级翻转就是一个`低优先级`的进程使用`临界区`资源时,即使现在有高优先级的进程想使用临界区资源,也只能被阻塞.可是此时假如有中优先级但不使用临界区资源的进程就绪, CPU就要先处理中优先级的进程, 这就造成了高优先级的持续等待.
3. 进程同步: 系统中多个进程中发生的事件存在某种时序关系, 需要相互合作,共同完成某项任务. 比如一个进程需要另一个进程的消息, 在没有得到消息之前, 该进程进入阻塞态. 
4. 生产者/消费者问题:又称有界缓冲区问题. 指一个或者多个生产者产生某种数据并放置在缓冲区中, 有消费者从缓冲区中取数据, 每次只能有一个生产者或者消费者对缓冲区进行操作.   
要解决的问题: 满的时候不允许生产者再去存放数据. 空的时候不允许消费者再取走数据.  
要避免忙等待: 等待的时候让出CPU, 所以引入睡眠和唤醒原语. 对于生产者, 如果缓冲区满了, 就让他sleep()
5. 信号量: 一个用于进程间传递信息的整数值. 对信号量可以执行的操作只有初始化, P操作(test)和V(increment)操作.  
P操作(Down, SemWait): 信号量减1, 判断如果<0, 进程设置为阻塞态, 放入等待队列.   
V操作(Up, SemSignal): 信号量+1, 判断如果>=0, 从等待队列中唤醒一个进程, 改变其状态为就绪态, 并插入就绪队列. PV操作是原语操作, 关闭中断. 最初提出二元信号量, 解决互斥问题, 后来推广到计数信号量, 解决同步问题. 

PV操作解决互斥问题:  
- 分析并发进程的关键活动, 划分临界区
- 设置信号量mutex, 初值为1
- 临界区前使用P操作
- 临界区之后使用V操作.

