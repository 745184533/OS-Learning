# OS Study Notes
> Orange's 一个操作系统的实现 阅读笔记

### NASM
什么是NASM?  
NASM是一个为可移植性与模块化而设计的一个80x86的汇编器。它支持相当多
的目标文件格式，包括Linux和'NetBSD/FreeBSD','a.out','ELF','COFF',微软16
位的'OBJ'和'Win32'。它还可以输出纯二进制文件。它的语法设计得相当的简
洁易懂，和Intel语法相似但更简单。它支持'Pentium','P6','MMX','3DNow!',
'SSE' and 'SSE2'指令集.   
  
在NASM中, 任何不被方括号[]括起来的标签或者变量名都被认为是地址, 访问标签中的内容必须使用[].所以:  
```Assembly
mov ax, BootMessage
BootMessage:    db  "Hello, OS World!"
```  
将会把这个字符串的首地址送到ax中. 如果有
```Assembly
foo     dw      1
mov     ax, foo;    将把foo的地址放入ax中
mov     bx, [foo];  将把foo的值(1)放入bx中
```

`offset`这个关键字在NASM中也是不需要的, 因为不加`[]`时就表示offset.

### 汇编指令
* ORG是Origin的缩写：起始地址，源。在汇编语言源程序的开始通常都用一条ORG伪指令来实现规定程序的起始地址。如果不用ORG规定则汇编得到的目标程序将从0000H开始。例如：
```Assembly
 　　      ORG 2000H 　　
    START：MOV  AX，#00H
```
汇编语言源程序中若没有ORG伪指令，则程序执行时，指令代码被放到自由内存空间的CS:0处；若有ORG伪指令，编译器则把其后的指令代码放到ORG伪指令指定的偏移地址。两个ORG伪指令之间，除了指令代码，若有自由空间，则用0填充。

* JMP $  
$，代表当前地址。
$ 放在 LJMP 之后，它就代表这条指令本身的地址。
JMP $，就是转移到该指令的本身地址。
JMP $，就是原地转移的意思，即 死循环。
一旦有中断发生，就可以去执行中断程序。
注: 而`$$`表示一个节(section)的开始处被汇编的地址. 在写程序的过程中, `$-$$`会经常用到.表示`本行距离程序开始处的相对距离`.  
`times   510-($-$$)  db  0;`表示将0这个字节重复`510-($-$$)`遍也就是剩下的空间都填充0直到510. 

* SHL，将目的操作数顺序左移1位或CL寄存器中指定的位数。左移一位时，操作数的最高位移入进位标志位CF，最低位补零。

### 引导扇区
当计算机电源被打开, 会先进行加电自检(POST), 然后寻找启动盘, 如果是选择从软盘启动, 计算机就会去检查软盘的`0面0磁道1扇区`, 如果它以`0xAA55`结束, 则BIOS认为它是一个引导扇区. 一个正确的引导扇区除了以0xaa55结束以外, 还应该包含一段少于512个字节的执行码. 接下来, 一旦BIOS发现了引导扇区, 就会将这512个字节的内容装载到内存地址`0000:7c00`处, 然后跳转到`0000:7c00`彻底将控制权交给这段代码. 到此为止, 计算机不再由BIOS控制, 而变成操作系统的一部分来控制.


### 调试
在Windows下, 可以选择的调试方法包括把引导扇区的代码的`ORG 07c00h`改为`ORG 0100h`就可以编译成一个.COM文件在DOS下运行了. 
调试环境: Bochs  
Bochs（发音：box）是一个以GNU宽通用公共许可证发放的开放源代码的x86、x86-64IBM PC兼容机模拟器和调试工具。它支持处理器（包括保护模式），内存，硬盘，显示器，以太网，BIOS，IBM PC兼容机的常见硬件外设的仿真。    
许多客户操作系统能通过该仿真器运行，包括DOS，Microsoft Windows的一些版本, AmigaOS 4, BSD, Linux, MorphOS, Xenix和Rhapsody (Mac OS X的前身).  Bochs能在许多主机操作系统运行，例如Windows, Windows Mobile, Linux, Mac OS X, iOS, PlayStation 2.  
Bochs主要用于操作系统开发（当一个模拟操作系统崩溃，它不崩溃主机操作系统，所以可以调试仿真操作系统）和在主机操作系统运行其他来宾操作系统。它也可以用来运行不兼容的旧的软件（如电脑游戏）。  
它的优点在于能够模拟跟主机不同的机种，例如在Sparc系统里模拟x86，但缺点是它的速度却慢得多。

`bximage`: 生成虚拟软盘(floppy disk)或虚拟硬盘(hard disk)    
`dd if=boot.bin of=a.img bs=512 count=1 conv=nontrunc   ; 将引导扇区写进软盘`  
最后一个参数表示不裁剪,不截断(truncated). 使用真实软盘装载时不需要此参数, 因为真的不会被截断.
然后再`a.img`所在目录下新建`bochsrc`配置文件, 然后在终端输入`bochs`即可运行. 如果运行黑屏则是调试模式, 终端输入`c`解决.

当程序越来越大的时候, 限定引导扇区空间为512个字节就会造成错误.解决办法(1)写一个引导扇区,可以读取程序并运行;(2)借助别的东西,比如DOS, 把程序编译成COM文件, 让DOS执行它.



### souce命令
source命令也称为“点命令”，也就是一个点符号（.）。source命令通常用于重新执行刚修改的初始化文件，使之立即生效，而不必注销并重新登录。

### bochs调试命令
1. b addr : 在`addr`处设置断点 例: `b 0x30440`
2. c:       继续执行, 直到遇到断点
3. s:       单步执行
4. n:       单步执行, 遇到函数直接跳出
5. 


### 伪指令
指令是在执行阶段发挥作用的，由CPU（Intel、AMD等）来执行。伪指令是在编译阶段发挥作用的，由汇编器（MASM、TASM等）来解释。  
- db定义字节类型变量，一个字节数据占1个字节单元(8Bit)，读完一个，偏移量加1
- dw定义字类型变量，一个字数据占2个字节单元(16Bit)，读完一个，偏移量加2  
- dd定义双字类型变量，一个双字数据占4个字节单元(32Bit)，读完一个，偏移量加4

在段[SECTION .gdt]中并列有3个Descriptor, 看上去是个结构数组.这个数组的名字叫`Descriptor`. GdtLen是GDT的长度, GdtPtr也是个数据结构, 6个字节, 前2个是GDT的界限, 后4个是GDT的基地址.(GDT: Global Descriptor Table)

### 寄存器
首先 cpu中寄存器用于存储内存中数据的物理地址.
- cs 为代码段寄存器，一般用于存放代码.通常和IP 使用用于处理下一条执行的代码  
`cs:IP`  
基地址：偏移地址. cs地址对应的数据 相当于c语言中的代码语句. 

- ds 为数据段寄存器，一般用于存放数据. ds地址对应的数据 相当于c语言中的全局变量.

- ss 为栈段寄存器，一般作为栈使用 和sp搭档；ss地址对应的数据 相当于c语言中的局部变量.  
ss相当于堆栈段的首地址,sp相当于堆栈段的偏移地址.

- es 为扩展段寄存器.

### 保护模式
关于IA32和X86:
- IA32 : 32 bits Intel Architecture (32位带宽Intel构架)
- IA64 : 64 bits Intel Architecture (64位带宽Intel构架)
- i386 : Intel 386 ( 老的386机器，也泛指IA32体系的CPU)
- i486 : Intel 486
- i586 : Intel 586 ( Pentium ,K6 级别CPU )
- i686 : Intel 686 ( Pentium II, Pentium III , Pentim 4, K7 级别CPU )

以上的86 也可以叫做 x86， 通称说 x86也是指 IA32构架CPU. x86是一个intel通用计算机系列的编号,也标识一套通用的计算机指令.集合。
在IA32下, CPU有2种工作模式: 实模式和保护模式. 打开PC, 开始时CPU是工作在实模式下的, 经过某种机制后,才进入保护模式.   
保护模式下, CPU有着巨大的寻址能力, 并为强大的32位操作系统提供了更好的硬件保障. 

实模式:   
Intel 8086是16位CPU, 有着16位寄存器, 16位数据总线, 20位地址总线和1MB寻址能力(2^20). 一个地址由段和偏移2部分组成, 物理地址遵循计算公式:  
`物理地址(physical address) = 段值(segment)*16 + 偏移(offset)`  
段值和偏移都是16位. 

保护模式:   
新模式下的地址仍然用"段: 偏移"这样的形式来表示. 只不过保护模式下的__段__的概念发生了根本性地变化. 实模式下, 段值还是可以看做是地址的一部分的. 而保护模式下, 虽然段值仍然由原来16位的cs, ds等寄存器表示, 但此时它仅仅变成了一个索引. 这个索引指向一个数据结构的一个表项, 表项中详细定义了段的起始地址, 界限, 属性等. 这个数据结构, 就是__GDT__.  GDT的作用是用来提供段式存储机制, 这种机制通过段寄存器和GDT中的描述符共同提供的. GDT: Global Descriptor table.  

代码段和数据段描述符:  
| Byte7       | Byte6 | Byte 5   | Byte 4|Byte 3|Byte 2| Byte 1 | Byte 0|
|31..24 段基址2|    属性等         | 23..0 段基址1        | 15..0 段界限1   |

Selector选择子:  
- 15..3: 描述符索引; 
- 2: TI;
- 1..0: RPL;
当TI和RPL都为0时, 选择子就变成了对应描述符相对于GDT基址的偏移.



打开地址线A20: 8086时, 只有20条地址总线, 寻址超过1MB, 直接wrap回去重新从地址零开始寻址. 可是到80286, 可以访问到1MB以上的空间了, 系统不再wrap回到开头. 为了向上兼容, 使用8042键盘控制器来控制第20个地址位, 就是A20地址线(8086时, A0~A19),如果不被打开, 第20个地址位将总会是0. 为了访问所有内存, 需要把A20打开, 开机时默认它是关闭的. 要打开就要操作端口92h. 


### 页式存储
页: 就是一块内存, 80386中, 页的大小是固定的4096字节(4KB). Pentium中, 页的大小还可以是2MB或者4MB.   
在未打开分页机制时, 线性地址等同于物理地址, 所以可以理解为逻辑地址通过分段机制直接转换成物理地址. 但当分页开启时, 情况发生变化, 分__段__机制(segment)将逻辑地址转换成线性地址, 线性地址再通过分__页__机制转换成物理地址.  
分页的主要目的是实现虚拟存储器. 
 
转换使用两级页表, 第一级叫做页目录, 大小4KB, 存储在一个物理页中, 每个表项4字节长, 共有1024个表项, 每一个表项对应第二级的一个页表, 第二级的每一个页表也有1024个表项, 每个表项对应一个物理页. 页目录表的表项简称PDE, Page Directory Entry. 页表的表项简称PTE, Page Table Entry.

CR3: 又叫做PDBR, Page-Directory Base Register. 高20位是页目录表首地址的高20位,页目录表首地址的低12位会是0(页目录表是4KB对齐的). 














